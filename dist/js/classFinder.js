/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/webpages/classFinder.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/dataFormatting/classDB.js":
/*!***************************************!*\
  !*** ./src/dataFormatting/classDB.js ***!
  \***************************************/
/*! exports provided: ClassDB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ClassDB\", function() { return ClassDB; });\n/*\r\nClassDB is used by the Main class to store the data used by the class locator.\r\nOnce again, the HTML file does the populating\r\n\r\nPLEASE. DATABASE FOR THIS!!!\r\n*/\nclass ClassDB {\n  constructor() {\n    //number is the five digit class number\n    let headers = [\"NUMBER\", \"NAME\", \"INSTRUCTOR\", \"ROOM\", \"MEETING TIME\"];\n    this.headers = [];\n    this.rows = [];\n    this.headerString = \"\";\n    let h;\n\n    for (let i = 0; i < headers.length; i++) {\n      h = headers[i].toString().toUpperCase();\n\n      while (h.indexOf(\" \") !== -1) {\n        h = h.replace(\" \", \"_\");\n      }\n\n      this.headers.push(h);\n      this.headerString += h + \" \";\n      this[h] = i; //makes enum\n    }\n\n    this.sourceHeaders = [];\n  }\n\n  parseResponse(csvFile) {\n    \"use strict\";\n\n    let data = csvFile.getNonHeaders();\n    let classNumCol = csvFile.indexOfCol([\"CLASS #\", \"CLASS NUMBER\"]);\n    let subjCol = csvFile.indexOfCol([\"SUBJ CD\", \"SUBJECT\"]);\n    let numCol = csvFile.indexOfCol([\"CAT NBR\", \"NUMBER\"]);\n    let startTimeCol = csvFile.indexOfCol([\"BEG TIME\", \"START TIME\"]);\n    let endTimeCol = csvFile.indexOfCol([\"END TIME\"]);\n    let daysCol = csvFile.indexOfCol([\"DAYS\"]);\n    let buildingCol = csvFile.indexOfCol([\"BUILDING\"]);\n    let roomCol = csvFile.indexOfCol([\"ROOM\"]);\n    let instructorCol = csvFile.indexOfCol([\"INSTRCTR\", \"INSTRUCTOR\"]);\n    let row;\n    let name; //skip headers\n\n    for (let i = 1; i < data.length; i++) {\n      row = data[i];\n\n      try {\n        //name = row[instructorCol.]\n        this.rows.push([row[classNumCol], row[subjCol] + \" \" + row[numCol], row[instructorCol], row[buildingCol] + \" \" + row[roomCol], row[daysCol] + \" \" + row[startTimeCol] + \" - \" + row[endTimeCol]]);\n      } catch (e) {\n        console.log(e.stack);\n      }\n    }\n  }\n\n  selectF(retCol, checkCol, callback) {\n    /*\r\n          @param retCol : an int, the index of the column to return. Should be an enum value of this db\r\n          @param checkCol : an int, the index of the column to compare to checkVal\r\n          @param callback : a function which takes something as a parameter, and returns true or false\r\n          @return an array of any single type, containing any values from retCol from rows\r\n              where callback(checkCol) is true\r\n          \r\n          SELECT retCol FROM database WHERE callback(checkCol)\r\n          */\n    \"use strict\";\n\n    let ret = [];\n\n    try {\n      //checking\n      if (retCol >= this.headers.length) {\n        throw new RangeError(\"Invalid index for retCol\");\n      }\n\n      if (checkCol >= this.headers.length) {\n        throw new RangeError(\"Invalid index for checkCol\");\n      }\n\n      this.rows.forEach(row => {\n        let check = row[checkCol];\n\n        if (callback(check)) {\n          ret.push(row[retCol]);\n        }\n      });\n    } catch (e) {\n      console.log(e.stack);\n    }\n\n    return ret;\n  }\n\n  select(retCol, checkCol, checkVal) {\n    /*\r\n          @param retCol : an int, the index of the column to return. Should be an enum value of this db\r\n          @param checkCol : an int, the index of the column to compare to checkVal\r\n          @param checkVal : can be any type, the value to compare checkCol to\r\n          @return an array of any single type, containing any values from retCol from rows\r\n              where checkCol === checkVal\r\n          \r\n          SELECT retCol FROM database WHERE checkCol=checkVal;\r\n    maybe add returning a new Database?\r\n          */\n    \"use strict\";\n\n    checkVal = checkVal.toString().toUpperCase();\n    return this.selectF(retCol, checkCol, data => data.toString().toUpperCase() === checkVal);\n  }\n\n  getColumn(col) {\n    /*\r\n          @param col : an int, an enum value for this, the column number to return\r\n          @return an array containing each unique value from the given column\r\n          SELECT DISTINCT columnName FROM database\r\n          */\n    \"use strict\";\n\n    let ret = [];\n\n    if (col >= this.headers.length) {\n      throw new RangeError(\"Invalid column\");\n    }\n\n    let item;\n\n    try {\n      for (let i = 0; i < this.rows.length; i++) {\n        item = this.rows[i][col];\n\n        if (ret.indexOf(item) === -1) {\n          ret.push(item);\n        }\n      }\n    } catch (e) {\n      console.log(e.stack);\n    }\n\n    return ret;\n  }\n\n  getNumbersByName(className) {\n    \"use strict\";\n\n    return this.select(this.NUMBER, this.NAME, className.toUpperCase());\n  }\n\n  getNumbersByInstructor(instructorName) {\n    \"use strict\";\n\n    return this.select(this.NUMBER, this.INSTRUCTOR, instructorName.toUpperCase());\n  }\n\n  getNumbersByTime(time) {\n    \"use strict\";\n\n    return this.select(this.NUMBER, this.MEETING_TIME, time.toUpperCase());\n  }\n\n  getAllClassNumbers() {\n    \"use strict\";\n\n    return this.getColumn(this.NUMBER);\n  }\n\n  getAllClassNames() {\n    \"use strict\";\n\n    return this.getColumn(this.NAME);\n  }\n\n  getAllInstructors() {\n    \"use strict\";\n\n    return this.getColumn(this.INSTRUCTOR);\n  }\n\n  getAllMeetingTimes() {\n    \"use strict\";\n\n    return this.getColumn(this.MEETING_TIME);\n  }\n\n  logAll() {\n    /*\r\n    prints the contents of the database\r\n    SELECT * FROM this\r\n    */\n    \"use strict\";\n\n    console.log(this.headerString);\n\n    for (let i = 0; i < this.rows.length; i++) {\n      let row = \"\";\n\n      for (let j = 0; j < this.rows[i].length; j++) {\n        row += this.rows[i][j];\n\n        if (j !== this.rows[i].length - 1) {\n          row += \", \";\n        }\n      }\n\n      console.log(row);\n    }\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/dataFormatting/classDB.js?");

/***/ }),

/***/ "./src/dataFormatting/csv.js":
/*!***********************************!*\
  !*** ./src/dataFormatting/csv.js ***!
  \***********************************/
/*! exports provided: formatResponse, CsvFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatResponse\", function() { return formatResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CsvFile\", function() { return CsvFile; });\n/*\r\nProvides the CsvFile class\r\n\r\nThe CsvFile class is used to format imported data from spreadsheets to a format usable by the program.\r\n\r\n Since Matt will be developing an app to manage the data used by the program, \r\n we may get rid of this later,\r\n as then it will always be in exactly the format we want.\r\n */\nfunction formatResponse(responseText) {\n  \"use strict\";\n\n  let ret = [];\n  let splitOnLine = responseText.split(/\\r?\\n|\\r/); //split on newline\n\n  splitOnLine.forEach(line => ret.push(line.split(\",\")));\n  return ret;\n}\nclass CsvFile {\n  constructor(text) {\n    /*\r\n    @param text : a String, the response text from an HTTP request\r\n    */\n    \"use strict\";\n\n    this.headers = [];\n    this.data = formatResponse(text);\n    this.headers = this.data[0].map(header => header.toUpperCase());\n  }\n\n  getNonHeaders() {\n    /*\r\n    @return an array of arrays of strings, each row of this' data, sans the first, which is headers\r\n    */\n    \"use strict\";\n\n    return this.data.slice(1, this.data.length);\n  }\n\n  indexOfCol(possibleHeaders) {\n    /*\r\n    @param possibleHeaders : an array of strings, possible names of the header we're searching for\r\n    @return an int : the index of one of this' headers contained in possibleHeaders\r\n    if none of the headers in possibleHeaders exists in this' headers, returns -1\r\n    */\n    \"use strict\";\n\n    let ret = -1;\n\n    if (!Array.isArray(possibleHeaders)) {\n      possibleHeaders = [possibleHeaders];\n    }\n\n    possibleHeaders = possibleHeaders.map(header => header.toUpperCase());\n\n    for (let i = 0; i < this.headers.length && ret === -1; i++) {\n      if (possibleHeaders.indexOf(this.headers[i]) !== -1) {\n        ret = i;\n      }\n    }\n\n    return ret;\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/dataFormatting/csv.js?");

/***/ }),

/***/ "./src/getRequests/importData.js":
/*!***************************************!*\
  !*** ./src/getRequests/importData.js ***!
  \***************************************/
/*! exports provided: newline, logger, get, sequentialGets, importMasterSheet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"newline\", function() { return newline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logger\", function() { return logger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sequentialGets\", function() { return sequentialGets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"importMasterSheet\", function() { return importMasterSheet; });\n/* harmony import */ var _dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dataFormatting/csv.js */ \"./src/dataFormatting/csv.js\");\n/*\r\nProvides functions which are used to perform XMLHTTPRequests.\r\nThese are invoked in the html files.\r\n*/\n\nconst newline = /\\r?\\n|\\r/; //used for debugging\n\nconst logger = {\n  contents: [],\n\n  add(msg) {\n    \"use strict\";\n\n    this.contents.push(msg);\n  },\n\n  displayAll() {\n    \"use strict\";\n\n    for (let i = 0; i < this.contents.length; i++) {\n      console.log(this.contents[i]);\n    }\n  }\n\n}; // basic http request functions\n\nfunction get(url, callback) {\n  // callback is a function with a single parameter,\n  // passes in the url's response text as that parameter\n  \"use strict\";\n\n  let req = new XMLHttpRequest();\n\n  req.onreadystatechange = function () {\n    if (req.readyState === 4 && req.status === 200) {\n      logger.add(\"Response from \" + url + \":\");\n      logger.add(req.responseText);\n      callback(req.responseText);\n    }\n  };\n\n  req.onerror = function (e) {\n    console.log(e);\n    callback(\"\");\n  };\n\n  req.open(\"GET\", url, true); // true means asynchronous\n\n  req.setRequestHeader(\"Cache-Control\", \"max-age=0\"); // prevent outdated data\n\n  req.send(null);\n}\nfunction sequentialGets(urls, callbacks) {\n  /*\r\n  @param urls : an array of strings, the urls to get\r\n  @param callbacks : either...\r\n  (a): an array of functions, each taking a string as a paramter\r\n  (b): a single element array or function, taking an array of strings as a parameter\r\n    performs a get request on each url, then...\r\n  (a): if multiple callbacks are provided, passes in responses[i] to callback[i]\r\n  (b): if only one callback is passed (one element array, or just a function), passes in all responses as an array to that function\r\n  */\n  \"use strict\";\n\n  let responses = [];\n  let received = 0;\n  let singleFunction = !Array.isArray(callbacks) || callbacks.length === 1;\n\n  if (!Array.isArray(callbacks)) {\n    callbacks = [callbacks]; //make sure it's an array. Can't use singleFunction b/c single element array would cause problems\n  }\n\n  function finish() {\n    if (singleFunction) {\n      callbacks[0](responses);\n    } else {\n      for (let i = 0; i < responses.length && i < callbacks.length; i++) {\n        callbacks[i](responses[i]);\n      }\n    }\n  }\n\n  function f(i) {\n    return function (responseText) {\n      responses[i] = responseText;\n      received++;\n\n      if (received === urls.length) {\n        finish();\n      }\n    };\n  }\n\n  for (let i = 0; i < urls.length; i++) {\n    responses.push(\"No response from URL \" + urls[i]);\n    get(urls[i], f(i));\n  }\n} // improve this\n\nfunction importMasterSheet(url, callbacks, ignore = []) {\n  /*\r\n   * @param url : a string, the \r\n   * url of the master url file\r\n   * on our google drive\r\n   * \r\n   * @param callback : a function\r\n   * \r\n   * This performs a get request on the master url spreadsheet,\r\n   * then performs a get request on each url on the spreadsheet,\r\n   * then passes each URL into the callback function\r\n   * \r\n   * (improve later)\r\n   */\n  get(url, responseText => {\n    let data = Object(_dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_0__[\"formatResponse\"])(responseText);\n    let urls = [];\n\n    for (let i = 1; i < data.length; i++) {\n      if (data[i][1] !== \"\" && ignore.indexOf(data[i][0]) === -1) {\n        urls.push(data[i][1]);\n      }\n    }\n\n    console.log(urls);\n    sequentialGets(urls, callbacks);\n  });\n}\n\n//# sourceURL=webpack:///./src/getRequests/importData.js?");

/***/ }),

/***/ "./src/getRequests/urls.js":
/*!*********************************!*\
  !*** ./src/getRequests/urls.js ***!
  \*********************************/
/*! exports provided: mapURL, classesURL, masterSheetURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapURL\", function() { return mapURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"classesURL\", function() { return classesURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"masterSheetURL\", function() { return masterSheetURL; });\n/*\r\nThis file is used to specify the URLs used by this program to reteive data from external files.\r\n\r\n!!!!!\r\nIMPORTANT!!! : do NOT change ANYTHING to the left of the equal signs on each line! Doing so WILL break the program!\r\n!!!!!\r\n\r\nBefore changing this file, it might be a good idea to save a copy in case something goes wrong...\r\n*/\nconst mapURL = \"https://drive.google.com/uc?id=1Lt58PPBmimpY8hIlCJgg4qvF8CLt_mis\"; // this links to an image that is used as the campus map\n\n/*\r\nHOW TO CHANGE THE mapURL FILE:\r\n    Can't do yet, unless the map shows the same section of campus as the current one.\r\n\t1. Put a .png file into google drive.\r\n\t2. copy that image's URL using \"get sharable link\"\r\n\t3. paste the URL after var mapURL = ... in place of the existing URL\r\n\t4. make sure there are quote marks around the URL (can be double or single quotes)\r\n\t5. replace the \"open\" in the URL with \"uc\"\r\n\t6. ???\r\n*/\n\nconst classesURL = \"https://docs.google.com/spreadsheets/d/e/2PACX-1vREUvLP1uMDKADze2uCHx6jN4voxvO41g-gZ5pEDK_vJ0M9LA7UmfRgqJeX_NRDZsMMC_lOs2A0OKtm/pub?gid=57491238&single=true&output=csv\"; //the huge class data extract\n//export const masterSheetURL = \"https://docs.google.com/spreadsheets/d/e/2PACX-1vR-FO3lDmriTqDlwZkp9A3bxVMhJUiQ2l6OiCJboyuPyhOafAxyh0DYDjF0sz28xfotVj8xbJ2zSzrc/pub?gid=0&single=true&output=csv\";\n\nconst masterSheetURL = \"https://docs.google.com/spreadsheets/d/e/2PACX-1vSuRqzSZ2LyamtAz7Gs88JkOiBmyIx8ND6kqRhxbunGVPBw4Wqrc1yYgfjFeC6m_Dx0sbXTE4Q5k3uQ/pub?gid=0&single=true&output=csv\"; //the master spreadsheet containing links to all the data used by the program\n\n//# sourceURL=webpack:///./src/getRequests/urls.js?");

/***/ }),

/***/ "./src/htmlInterface/input.js":
/*!************************************!*\
  !*** ./src/htmlInterface/input.js ***!
  \************************************/
/*! exports provided: TextBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextBox\", function() { return TextBox; });\n/*\r\nused to take input from the user\r\n\r\nfirst, accesses or creates two HTML elements,\r\none used for user input,\r\nthe second displays the closest match to what the user entered (see below)\r\n\r\nafter creating a TextBox, you will need to populate its option by calling...\r\ntextBox.addOptions(anArray);\r\n\r\nwhenever the user types in the text box, \r\nthe result element will search through options for the closest match to what the user entered,\r\nthen sets its text to that match.\r\n*/\nclass TextBox {\n  constructor(textBoxId, resultElementId) {\n    /*\r\n    @param textBoxId : a string, the id of an <input> HTML element with type=\"text\"\r\n    @param resultElementId : a string, the id of any HTML element whose inner HTML \r\n    will enter the option closest to the user's input\r\n      if either of the aforementioned elements don't exist, will create them instead\r\n    */\n    \"use strict\";\n\n    this.box = document.getElementById(textBoxId);\n    this.resultElement = document.getElementById(resultElementId);\n\n    if (this.box === null) {\n      this.box = document.createElement(\"input\");\n      this.box.setAttribute(\"type\", \"text\");\n      this.box.setAttribute(\"id\", textBoxId);\n      document.body.appendChild(this.box);\n    }\n\n    if (this.resultElement === null) {\n      this.resultElement = document.createElement(\"div\");\n      this.resultElement.setAttribute(\"id\", resultElementId);\n      document.body.appendChild(this.resultElement);\n    }\n\n    this.options = [\"your result will appear here!\"];\n    this.resultElement.innerHTML = \"your result will appear here!\";\n    this.box.oninput = this.updateResult.bind(this);\n  }\n\n  addOptions(options) {\n    /*\r\n    @param options : an array of strings\r\n    */\n    \"use strict\";\n\n    let b = this;\n    options.forEach(option => {\n      if (option) {\n        b.options.push(option.toString().toUpperCase());\n      }\n    });\n  }\n\n  updateResult() {\n    // makes the result search for the closest match in options to what the user's entered\n    \"use strict\";\n\n    this.resultElement.innerHTML = closestMatch(this.box.value, this.options);\n  }\n\n  isValid() {\n    //legal input was entered\n    \"use strict\"; //want to make sure the closest match is both in the options, and not the default option\n\n    return this.options.indexOf(this.resultElement.innerHTML.toUpperCase()) > 0;\n  }\n\n  setInput(str) {\n    //@param str : a string, what to put in the input box\n    //basically makes the program act as the user, typing str in the box\n    \"use strict\";\n\n    this.box.value = str;\n    this.box.oninput();\n  }\n\n  getResult() {\n    /*\r\n    @return : a string, the closest match to what the user inputted\r\n    */\n    \"use strict\";\n\n    return this.resultElement.innerHTML;\n  }\n\n}\n;\n\nfunction matchCount(find, inString) {\n  \"use strict\";\n  /*\r\n  returns the number of characters in find\r\n  that are in inString in order\r\n  */\n\n  find = find.toUpperCase();\n  inString = inString.toUpperCase();\n  let best = 0;\n  let spaces = 0;\n  let matchIdx; //the index in inString of the most recent letter match\n\n  let current;\n  let currentSpaces; // matchCount(\"string\", \"stri\") whould get a best of 4 on the first run,\n  // the next check would be for \"tring\" in \"stri\". (offset = 1)\n  // would not check with offset = 2, as it could not have more than 4 matches,\n  // so cannot be better than the current best of 4\n\n  for (let offset = 0; offset < find.length - best; offset++) {\n    current = 0; //number of matches in current substring\n\n    currentSpaces = 0;\n    matchIdx = 0;\n\n    for (let ind = 0; ind < inString.length && offset + current < find.length; ind++) {\n      //find[offset + current] will check the second character of the find substring after finding one match\n      //guarantees that the letters are in order\n      if (find[offset + current] === inString[ind]) {\n        current++;\n\n        if (current > 1) {\n          currentSpaces += ind - matchIdx - 1;\n        } else {\n          currentSpaces += ind;\n        }\n\n        matchIdx = ind;\n      }\n    }\n\n    if (current > best) {\n      best = current;\n      spaces = currentSpaces;\n    }\n  }\n\n  return {\n    \"matches\": best,\n    \"spaces\": spaces\n  };\n}\n\nfunction closestMatchIndex(string, options) {\n  \"use strict\";\n\n  let s = string.trim().toUpperCase();\n  let check = [];\n  let best = 0;\n  let leastSpaces = string.length;\n  let idxOfBest = 0;\n  let count;\n\n  for (let i = 0; i < options.length; i++) {\n    check.push(options[i].trim().toUpperCase());\n    count = matchCount(s, check[i]);\n\n    if (count.matches > best) {\n      best = count.matches;\n      leastSpaces = count.spaces;\n      idxOfBest = i;\n    } else if (count.matches === best) {\n      if (count.spaces < leastSpaces) {\n        best = count.matches;\n        leastSpaces = count.spaces;\n        idxOfBest = i;\n      }\n    }\n  }\n\n  return idxOfBest;\n}\n\nfunction closestMatch(s, options) {\n  // returns the string in options which most closely resembles s\n  \"use strict\";\n\n  return options[closestMatchIndex(s, options)];\n}\n\n//# sourceURL=webpack:///./src/htmlInterface/input.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: Main */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Main\", function() { return Main; });\n/* harmony import */ var _nodes_path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nodes/path.js */ \"./src/nodes/path.js\");\n/*\r\nThe Main class is used to store data, preventing the need for global letiables.\r\nIt also takes a lot of code out of the main HTML file.\r\n*/\n\nclass Main {\n  constructor() {\n    \"use strict\";\n\n    this.canvas = undefined; //html elements\n\n    this.start = undefined;\n    this.end = undefined;\n    this.pathButton = undefined;\n    this.currentPath = undefined;\n    this.nodeDatabase = undefined;\n    this.classDatabase = undefined; //this.pathFinder = undefined; //need until we get rid of duplicate class ids\n  }\n\n  setCanvas(canvas) {\n    \"use strict\"; // canvas is my custom Canvas class, NOT HTML canvas\n\n    this.canvas = canvas;\n  }\n\n  getCanvas() {\n    \"use strict\";\n\n    return this.canvas;\n  }\n\n  setInput(start, end) {\n    /*\r\n    start and end are TextBoxes.\r\n    Populates said TextBoxes with the contents of this' fake database\r\n    */\n    \"use strict\";\n\n    this.start = start;\n    this.end = end;\n    start.addOptions(this.getNodeDB().getAllNames());\n    end.addOptions(this.getNodeDB().getAllNames());\n  }\n\n  setClassFinder(nameTextBox, instructorTextBox, timesTextBox, buttonId, resultsId, clearId) {\n    /*\r\n    loads the contents of this' Class database into the options of the three passed in text boxes,\r\n    then makes button change the contents of result based on the results of each of the three boxes when clicked\r\n    \r\n    @param nameTextBox : a TextBox, used to allow the user to enter the name of their class\r\n    @param instructorTextBox : also a TextBox, where the user enters the name of the instructor for their class\r\n    @param timesTextBox : once more, a TextBox, used to enter the meeting time(s) for the class\r\n    @param buttonId : the id of an HTML element that can handle onclick events\r\n    @param resultsId : the id of a select element which will display the class numbers the user is searching for once the button is clicked\r\n    @param clearId : the id of an HTML element that can handle onclick events which, when clicked, will clear out each of the user input boxes\r\n    if either the buttonId, resultsId, or clearId elements do not exist, creates them for you\r\n    */\n    \"use strict\";\n\n    let db = this.getClassDB();\n    let main = this;\n    let button = document.getElementById(buttonId);\n    let result = document.getElementById(resultsId);\n    let clear = document.getElementById(clearId);\n\n    if (button === null) {\n      button = document.createElement(\"button\");\n      button.setAttribute(\"id\", buttonId);\n      button.innerHTML = \"Find class number\";\n      document.body.appendChild(button);\n    }\n\n    if (result === null) {\n      result = document.createElement(\"select\");\n      result.setAttribute(\"id\", resultsId);\n      document.body.appendChild(result);\n    }\n\n    if (clear === null) {\n      clear = document.createElement(\"button\");\n      clear.setAttribute(\"id\", clearId);\n      clear.innerHTML = \"Clear input\";\n      document.body.appendChild(clear);\n    }\n\n    nameTextBox.addOptions(db.getAllClassNames());\n    instructorTextBox.addOptions(db.getAllInstructors());\n    timesTextBox.addOptions(db.getAllMeetingTimes());\n\n    button.onclick = function () {\n      //first, gather all the data fields, then get class numbers from them\n      function toInt(num) {\n        /*\r\n        can't just do .map(parseInt), \r\n        as map will implicitly pass in the index as the second parameter of parseInt,\r\n        which is the base of the string passed in,\r\n        causing errors.\r\n        If no second parameter is given, parseInt defaults to base 10\r\n        */\n        return parseInt(num);\n      }\n\n      let results = [main.getClassDB().getNumbersByName(nameTextBox.getResult()).map(toInt), main.getClassDB().getNumbersByInstructor(instructorTextBox.getResult()).map(toInt), main.getClassDB().getNumbersByTime(timesTextBox.getResult()).map(toInt)]; //this is an array of arrays\n\n      let validResults = []; //which results can be compared\n\n      let setTo = [\"class not found\"]; //what the dropbox will be set to\n      //then, check if the result set contains any data.\n      //this way, we won't be comparing valid data to an empty set\n\n      results.forEach(array => {\n        if (array.length > 0) {\n          validResults.push(array);\n        }\n      });\n\n      if (validResults.length === 0) {\n        setTo = [\"class not found\"];\n      } else if (validResults.length === 1) {\n        setTo = validResults[0];\n      } else {\n        //find a class present in each data set\n        //iterate through each element in the first set of valid results\n        validResults[0].forEach(item => {\n          setTo = [];\n          let match = true; //check if each other valid result set contains said value\n\n          for (let i = 1; i < validResults.length && match; i++) {\n            match = validResults[i].indexOf(item) !== -1;\n          }\n\n          if (match) {\n            setTo.push(item);\n          }\n        });\n      } //erase the current contents of dropdown\n\n\n      while (result.length > 0) {\n        result.remove(result.length - 1);\n      } //then repopulate it\n\n\n      let newElem;\n      setTo.forEach(opt => {\n        newElem = document.createElement(\"option\");\n        newElem.text = opt;\n        result.add(newElem);\n      });\n      result.onchange();\n    };\n\n    clear.onclick = function () {\n      nameTextBox.setInput(\"\");\n      instructorTextBox.setInput(\"\");\n      timesTextBox.setInput(\"\");\n    };\n\n    result.onchange = function () {\n      nameTextBox.setInput(db.select(db.NAME, db.NUMBER, result.value)[0]);\n      instructorTextBox.setInput(db.select(db.INSTRUCTOR, db.NUMBER, result.value)[0]);\n      timesTextBox.setInput(db.select(db.MEETING_TIME, db.NUMBER, result.value)[0]);\n    };\n  }\n\n  setPathButton(id) {\n    /*\r\n    id is the id of any HTML element\r\n    if it doesn't exist, will create it for you\r\n    */\n    \"use strict\";\n\n    this.pathButton = document.getElementById(id);\n\n    if (this.pathButton === null) {\n      this.pathButton = document.createElement(\"button\");\n      this.pathButton.setAttribute(\"id\", id);\n      this.pathButton.innerHTML = \"Draw Path\";\n      document.body.appendChild(this.pathButton);\n    }\n\n    let main = this;\n\n    this.pathButton.onclick = function () {\n      if (main.start.isValid() && main.end.isValid()) {\n        //updatepath does the finding\n        main.updatePath(main.start.getResult(), main.end.getResult());\n      }\n    };\n  }\n  /*\r\n  setPathFinder(pathFinder){\r\n  \t\"use strict\";\r\n  \tthis.pathFinder = pathFinder;\r\n  \tpathFinder.setDataSource(this);\r\n  }*/\n\n\n  setPath(path) {\n    \"use strict\";\n\n    if (path.valid) {\n      this.currentPath = path;\n\n      try {\n        path.draw(this.canvas);\n      } catch (e) {\n        console.log(\"Main's canvas is not defined yet\");\n        console.log(e.stack);\n      }\n    }\n  }\n\n  getPath() {\n    \"use strict\";\n\n    return this.currentPath;\n  }\n\n  updatePath(data1, data2) {\n    \"use strict\";\n\n    try {\n      let start = this.getNodeDB().getIdByString(data1);\n      let end = this.getNodeDB().getIdByString(data2); //single equal will catch both null and undefined\n\n      if (start != null && end != null) {\n        //otherwise some class numbers cause problems\n        let newPath = new _nodes_path_js__WEBPACK_IMPORTED_MODULE_0__[\"Path\"](start, end, this); //let newPath = this.pathFinder.find(data1, data2);\n\n        if (newPath.valid) {\n          this.setPath(newPath);\n        } else {\n          throw new Error(\"Invalid path: \" + newPath.idPath);\n        }\n      } else {\n        throw new Error(\"Invalid start and end points: \" + data1 + \" \" + data2);\n      }\n    } catch (e) {\n      console.log(e.stack);\n    }\n  }\n\n  testAllPaths() {\n    //developer tool. Detects any paths between any two nodes that cannot exist\n    \"use strict\";\n\n    let source = this;\n    let nodeDB = source.getNodeDB();\n    let points = [];\n    points = points.concat(nodeDB.getAllNames());\n\n    function checkPath(startStr, endStr) {\n      try {\n        let id1 = nodeDB.getIdByString(startStr);\n        let id2 = nodeDB.getIdByString(endStr); //getIdByString will log any errors\n\n        if (id1 != null && id2 != null) {\n          let path = new _nodes_path_js__WEBPACK_IMPORTED_MODULE_0__[\"Path\"](id1, id2, source);\n\n          if (!path.valid) {\n            throw new Error(\"Invalid Path: \" + path.idPath);\n          }\n        }\n      } catch (e) {\n        console.log(e.stack);\n      }\n    }\n\n    alert(\"Please wait while I process \" + points.length * points.length + \" paths...\");\n\n    for (let i = 0; i < points.length; i++) {\n      for (let j = 0; j < points.length; j++) {\n        checkPath(points[i], points[j]);\n      }\n    }\n\n    alert(\"Done.\");\n  }\n\n  setNodeDB(database) {\n    \"use strict\";\n\n    this.nodeDatabase = database;\n  }\n\n  getNodeDB() {\n    \"use strict\";\n\n    return this.nodeDatabase;\n  }\n\n  setClassDB(database) {\n    \"use strict\";\n\n    this.classDatabase = database;\n  }\n\n  getClassDB() {\n    \"use strict\";\n\n    return this.classDatabase;\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/nodes/path.js":
/*!***************************!*\
  !*** ./src/nodes/path.js ***!
  \***************************/
/*! exports provided: Path, PathFinder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path\", function() { return Path; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PathFinder\", function() { return PathFinder; });\n/*\r\nThis file contains two class: Path and PathFinder.\r\nPath is used to store a collection of Nodes that connect together\r\nto form a path between two Nodes, while PathFinder stores data and constructs Paths based on that data. \r\n\r\nHOW IT WORKS:\r\n1. a PathFinder is created, then given a data source: a Main object containing the node, building, and room databases used to find paths.\r\n2. after invoking 'pathFinder.find(buildingName, roomName), the pathFinder begins filtering data by...\r\n3. ...creating a list of each ID in its data source that links to a building with a name equal to the first parameter\r\n4. ...creating a list of each ID in its data source that links to a room with a nome equal to the second parameter\r\n5. afterwards, it constructs Paths using every possible combination of Nodes given by the building and room node IDs from steps 3 and 4 as start and end points respectively.\r\n6. once all possible paths are found, it returns the shortest one.\r\n\r\nHOW A PATH IS FOUND:\r\n1. Every Node has a list of Nodes that connect to it, called adjacent nodes.\r\n2. If node A is adjacent to node B, then a path exists between them.\r\n3. Similarly, if node B also connects to node C, then there exists a path A-B-C\r\n4. Now, repeat this process until there exists a path between the start and end points given.\r\nread this for a better explaination: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\n\r\nNO A-STAR: it is overkill in this case, and would make little difference.\r\n*/\n//use this in conjunction with Node\nclass Path {\n  constructor(startId, endId, dataSource) {\n    /*\r\n    start and endId are node IDs\r\n    dataSource is a main object\r\n    \r\n    idPath is an array of numbers, the ids of the nodes the path goes through\r\n    nodePath is the corresponding nodes\r\n    pathLength is the total length of the distance between all the nodes used in the path\r\n        it doesn't matter what scale it's in, as it is just used to compare in bestPath\r\n    images is an array of strings, the URLs of the path's images\r\n    imageInd is the index of the image currently displayed in main (in development)\r\n    */\n    \"use strict\";\n\n    this.startId = parseInt(startId);\n    this.endId = parseInt(endId);\n    this.dataSource = dataSource;\n    this.valid = true;\n    this.idPath = [];\n    this.nodePath = [];\n    this.pathLength = 0;\n    this.loadPath();\n    this.decodeIds();\n    this.images = this.getImages();\n    this.imgInd = -1; // increments before getting image\n  }\n\n  decodeIds() {\n    // generates nodePath\n    \"use strict\";\n\n    this.nodePath = [];\n\n    for (let i = 0; i < this.idPath.length; i++) {\n      this.nodePath[i] = this.dataSource.getNodeDB().getNode(this.idPath[i]);\n    }\n  }\n\n  loadPath() {\n    /*\r\n    this is the big one.\r\n    \t\tDijkstra's algorithm.\r\n    https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\n    Thanks Kevin\r\n    sets this.idPath to shortest path when complete\r\n    */\n    \"use strict\";\n\n    if (this.startId === this.endId) {\n      this.idPath = [this.startId];\n      this.pathLength = 0;\n      return;\n    }\n\n    let nodeDB = this.dataSource.getNodeDB();\n    let allNodes = nodeDB.getAll(); // start by declaring letiables\n\n    let unvisited = []; // unchecked nodes. Store as Node.\n\n    let dists = {}; // distances from start. Store as id : number\n\n    let prev = {}; // previous node in best path. Store as id : id\n    // initialize values\n\n    for (let i = 0; i < allNodes.length; i++) {\n      unvisited[i] = allNodes[i];\n      dists[allNodes[i].id] = Infinity;\n      prev[allNodes[i].id] = undefined;\n    }\n\n    dists[this.startId] = 0; // distance from start to start is 0\n\n    function smallestIndex() {\n      /*\r\n      Returns the index of the node with the shortest distance from start\r\n      that has yet to be visited\r\n      */\n      let index = 0;\n\n      for (let i = 0; i < unvisited.length; i++) {\n        if (dists[unvisited[i].id] < dists[unvisited[index].id]) {\n          index = i;\n        }\n      }\n\n      return index;\n    } // run while there are still nodes to visit\n\n\n    while (unvisited.length > 0) {\n      let index = smallestIndex();\n      let nearest = unvisited[index];\n      unvisited.splice(index, 1); // remove nearest from unvisited, as we are visiting it\n      // find which of its adjacent nodes are closest to start\n\n      for (let j = 0; j < nearest.adj.length; j++) {\n        if (unvisited.includes(nearest.adj[j])) {\n          let check = dists[nearest.id] + nearest.distanceFrom(nearest.adj[j]); // distance from start to i\n          //                                                V     is this right?\n\n          if (dists[nearest.adj[j].id] === Infinity || check < nearest.adj[j].distanceFrom(nodeDB.getNode(this.startId))) {\n            dists[nearest.adj[j].id] = check;\n            prev[nearest.adj[j].id] = nearest.id;\n          }\n        }\n      }\n    } // generate the path\n\n\n    let path = [];\n    let id = this.endId;\n\n    while (prev[id] !== undefined) {\n      path.push(id);\n      id = prev[id];\n    }\n\n    if (nodeDB.getNode(this.startId).adjIds.indexOf(path[path.length - 1]) !== -1) {\n      path.push(this.startId);\n    }\n\n    path = path.reverse();\n    this.idPath = path;\n    this.pathLength = dists[this.endId];\n\n    if (this.startId !== this.idPath[0] || this.endId !== this.idPath[this.idPath.length - 1]) {\n      this.invalidate();\n    }\n\n    if (this.startId < 0 || this.endId < 0) {\n      this.invalidate();\n    }\n  }\n\n  invalidate() {\n    \"use strict\";\n\n    if (this.valid) {\n      //prevent doubling up on this message\n      this.valid = false;\n\n      try {\n        console.log(\"Invalid path detected: \");\n        console.log(this);\n        throw new Error();\n      } catch (e) {\n        console.log(e.stack);\n      }\n    }\n  }\n\n  getURL() {\n    \"use strict\";\n\n    let origURL = window.location.href;\n    let split = origURL.split(\"?\");\n    return split[0] + \"?startID=\" + this.idPath[0] + \"&endID=\" + this.idPath[this.idPath.length - 1];\n  }\n\n  draw(canvas) {\n    \"use strict\";\n\n    canvas.clear();\n    canvas.setColor(\"red\");\n    let p = this.nodePath;\n    p[0].draw(canvas);\n\n    for (let i = 1; i < p.length; i++) {\n      canvas.line(p[i - 1].x, p[i - 1].y, p[i].x, p[i].y);\n      p[i].draw(canvas);\n    }\n  }\n\n  getImages() {\n    // returns an array of strings, each element is the url of a path image\n    \"use strict\";\n\n    let ret = [];\n    let ind = 0;\n\n    while (ind + 1 < this.idPath.length) {\n      ind++; // skips 0 so we can compare two nodes\n\n      let n1 = this.nodePath[ind - 1];\n      let n2 = this.nodePath[ind];\n\n      if (n1.getHasImage(n2.id)) {\n        let url = n1.getImageTo(n2.id);\n\n        if (ret.indexOf(url) === -1) {\n          ret.push(url);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  nextImage() {\n    // grabs the next image from this.images\n    \"use strict\"; // make sure not to go out of range\n\n    if (this.imgInd + 1 < this.images.length) {\n      this.imgInd++;\n    } else {\n      this.imgInd = 0;\n    }\n\n    return this.images.length !== 0 ? this.images[this.imgInd] : \" \"; // if this path has no images, return a blank string\n  }\n\n}\n;\n/*\r\nA PathFinder is used to store data, which is used to generate a path.\r\nmake sure it has a data source!\r\n\r\nmight still use\r\n*/\n\nclass PathFinder {\n  constructor() {\n    \"use strict\"; //dataSource is a Main object containing data used when constructing a path\n\n    this.dataSource = undefined;\n  }\n\n  setDataSource(main) {\n    \"use strict\";\n\n    this.dataSource = main;\n  }\n\n  find(data1, data2) {\n    /*\r\n    Finds which combination building entrances \r\n    create the most effective path between two\r\n    points.\r\n    \r\n    @param data1 : the starting point\r\n    @param data2 : the ending point\r\n    */\n    \"use strict\";\n\n    let startId = 14;\n    let endId = 96; //default to admin to hub\n\n    let valid = true;\n    startId = this.dataSource.getNodeDB().getIdByString(data1);\n    endId = this.dataSource.getNodeDB().getIdByString(data2);\n\n    if (startId === null) {\n      startId = -1;\n      valid = false;\n    }\n\n    if (endId === null) {\n      endId = -2;\n      valid = false;\n    }\n\n    let ret = new Path(startId, endId, this.dataSource);\n\n    if (!valid) {\n      ret.invalidate();\n    }\n\n    return ret;\n  }\n\n  testAll() {\n    //developer tool. Detects any paths between any two nodes that cannot exist\n    \"use strict\";\n\n    let source = this.dataSource;\n    let nodeDB = source.getNodeDB();\n    let allNodes = nodeDB.getAll();\n    let nodeCount = allNodes.length;\n\n    function checkPath(start, end) {\n      let path = new Path(start.id, end.id, source);\n\n      if (path.idPath[path.idPath.length - 1] !== end.id) {\n        console.log(\"An error occurred with path from \" + start.id + \" to \" + end.id);\n        console.log(\"The path returned was:\");\n        console.log(path.idPath);\n        console.log(\"IDs of the nodes adjacent to the ones used in this path are...\");\n\n        for (let k = 0; k < path.idPath.length; k++) {\n          console.log(\"*\" + path.idPath[k] + \": \" + path.nodePath[k].adjIds);\n        }\n      }\n    }\n\n    alert(\"Please wait while I process some information...\");\n\n    for (let i = 0; i < nodeCount; i++) {\n      for (let j = 0; j < nodeCount; j++) {\n        let start = allNodes[i];\n        let end = allNodes[j];\n\n        if (start.id >= 0 && end.id >= 0) {\n          //don't check corner nodes\n          checkPath(start, end);\n        }\n      }\n    }\n\n    alert(\"Done.\");\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/nodes/path.js?");

/***/ }),

/***/ "./src/webpages/classFinder.js":
/*!*************************************!*\
  !*** ./src/webpages/classFinder.js ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../main.js */ \"./src/main.js\");\n/* harmony import */ var _htmlInterface_input_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../htmlInterface/input.js */ \"./src/htmlInterface/input.js\");\n/* harmony import */ var _getRequests_importData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../getRequests/importData.js */ \"./src/getRequests/importData.js\");\n/* harmony import */ var _dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dataFormatting/csv.js */ \"./src/dataFormatting/csv.js\");\n/* harmony import */ var _dataFormatting_classDB_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dataFormatting/classDB.js */ \"./src/dataFormatting/classDB.js\");\n/* harmony import */ var _getRequests_urls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../getRequests/urls.js */ \"./src/getRequests/urls.js\");\n\n\n\n\n\n\nvar db = new _dataFormatting_classDB_js__WEBPACK_IMPORTED_MODULE_4__[\"ClassDB\"]();\nvar master = new _main_js__WEBPACK_IMPORTED_MODULE_0__[\"Main\"]();\nmaster.setClassDB(db);\nObject(_getRequests_importData_js__WEBPACK_IMPORTED_MODULE_2__[\"get\"])(_getRequests_urls_js__WEBPACK_IMPORTED_MODULE_5__[\"classesURL\"], responseText => {\n  db.parseResponse(new _dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_3__[\"CsvFile\"](responseText));\n  master.setClassFinder(new _htmlInterface_input_js__WEBPACK_IMPORTED_MODULE_1__[\"TextBox\"](\"name box\", \"name hint\"), new _htmlInterface_input_js__WEBPACK_IMPORTED_MODULE_1__[\"TextBox\"](\"instructor box\", \"instructor hint\"), new _htmlInterface_input_js__WEBPACK_IMPORTED_MODULE_1__[\"TextBox\"](\"time box\", \"time hint\"), \"find class\", \"class result\", \"clear\");\n});\n\n//# sourceURL=webpack:///./src/webpages/classFinder.js?");

/***/ })

/******/ });
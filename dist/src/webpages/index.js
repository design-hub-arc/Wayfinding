/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/webpages/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/dataFormatting/csv.js":
/*!***********************************!*\
  !*** ./src/dataFormatting/csv.js ***!
  \***********************************/
/*! exports provided: formatResponse, CsvFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatResponse\", function() { return formatResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CsvFile\", function() { return CsvFile; });\n/*\r\nProvides the CsvFile class\r\n\r\nThe CsvFile class is used to format imported data from spreadsheets to a format usable by the program.\r\n\r\n Since Matt will be developing an app to manage the data used by the program, \r\n we may get rid of this later,\r\n as then it will always be in exactly the format we want.\r\n */\nfunction formatResponse(responseText) {\n  /*\r\n  Converts the response from a csv file into a \r\n  two dimentional array.\r\n  If it already in the correct format, leaves it in that format.\r\n  */\n  let ret = [];\n\n  try {\n    let lines = Array.isArray(responseText) ? responseText : responseText.split(/\\r?\\n|\\r/); //split on newline\n\n    lines.forEach(line => {\n      ret.push(Array.isArray(line) ? line : line.split(\",\"));\n    });\n  } catch (e) {\n    console.log(e.stack);\n    console.log(\"response text is: \");\n    console.log(responseText);\n  }\n\n  return ret;\n}\nclass CsvFile {\n  constructor(text) {\n    /*\r\n    @param text : a String, the response text from an HTTP request\r\n    */\n    this.headers = [];\n    this.data = formatResponse(text);\n    this.headers = this.data[0].map(header => header.toUpperCase());\n  }\n\n  getNonHeaders() {\n    /*\r\n    @return an array of arrays of strings, each row of this' data, sans the first, which is headers\r\n    */\n    return this.data.slice(1, this.data.length);\n  }\n\n  indexOfCol(possibleHeaders) {\n    /*\r\n    @param possibleHeaders : an array of strings, possible names for the header we're searching for\r\n    @return an int : the index of one of this' headers contained in possibleHeaders\r\n    if none of the headers in possibleHeaders exists in this' headers, returns -1\r\n    */\n    let ret = -1;\n\n    if (!Array.isArray(possibleHeaders)) {\n      possibleHeaders = [possibleHeaders];\n    }\n\n    possibleHeaders = possibleHeaders.map(header => header.toUpperCase());\n\n    for (let i = 0; i < this.headers.length && ret === -1; i++) {\n      if (possibleHeaders.indexOf(this.headers[i]) !== -1) {\n        ret = i;\n      }\n    }\n\n    return ret;\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/dataFormatting/csv.js?");

/***/ }),

/***/ "./src/dataFormatting/nodeDB.js":
/*!**************************************!*\
  !*** ./src/dataFormatting/nodeDB.js ***!
  \**************************************/
/*! exports provided: NodeDB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NodeDB\", function() { return NodeDB; });\n/* harmony import */ var _nodes_arcNode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../nodes/arcNode.js */ \"./src/nodes/arcNode.js\");\n/* harmony import */ var _dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dataFormatting/csv.js */ \"./src/dataFormatting/csv.js\");\n\n\n/*\r\nNodeDB is used by the Main class to store the data used by the program.\r\nIt is initialized, filled with data, and applied to an instance of Main in\r\nthe HTML file.\r\n*/\n\nclass NodeDB {\n  constructor() {\n    this.nodes = new Map();\n    /*\r\n    Keys are integers, the node's ID, values are Node objects.\r\n    Note that while we could store them as an array,\r\n    we have nodes with negative IDs, and there are gaps in the IDs.\r\n    \r\n    Future versions of the node manager can get rid of this, \r\n    but shifting nodes -1 and -2 could be a problem,\r\n    as those specific IDs denote map corners.\r\n    */\n\n    this.stuffToNodeId = new Map();\n    /*\r\n    keys are a string, the name of the point (building/room/class name).\r\n    value is associated node ID.\r\n    \r\n    Since we go by the pattern of \"something\" has a node ID associated with it,\r\n    and we don't need to differentiate between rooms/buildings/etc,\r\n    I can store them all in one place.\r\n    \r\n    Not sure which is most efficient:\r\n    -Map\r\n    -Object\r\n    -Array\r\n    */\n  }\n\n  parseNodeData(responseText) {\n    /*\r\n    Reads the response from the node spreadsheet,\r\n    and creates and stores node objects based on that data.\r\n    \r\n    @param data : the result of an HTTP request to the node data spreadsheet, \r\n    can be either a string, or a two-dimentional array.\r\n    */\n    let data = Object(_dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_1__[\"formatResponse\"])(responseText);\n    let row;\n    let id;\n    let x;\n    let y;\n    let errors = []; //skip headers\n\n    for (let i = 1; i < data.length; i++) {\n      row = data[i];\n      id = parseInt(row[0]);\n      x = parseFloat(row[1]);\n      y = parseFloat(row[2]);\n\n      if (!isNaN(id) && !isNaN(x) && !isNaN(y) && !this.nodes.has(id)) {\n        this.nodes.set(id, new _nodes_arcNode_js__WEBPACK_IMPORTED_MODULE_0__[\"Node\"](id, x, y));\n      } else {\n        errors.push(\"An error occured for the line \" + row.join());\n      }\n    }\n\n    if (errors.length > 0) {\n      console.log(\"Something went wrong with parsing the node data:\");\n      errors.forEach(msg => console.log(\"--\" + msg));\n    }\n  }\n\n  parseNameToId(responseText) {\n    /*\r\n    responseText is the result of an HTTP request to a csv file, formatted as:\r\n        header1, header2\r\n    \tname, node id\r\n    \tname, node id\r\n    \t...\r\n    \r\n    This can be given as either a two-dimensional array,\r\n    or a string, which it will convert into a two-d array.\r\n    \r\n    Inserts the name and id rows into this' stuffToNodeId Map\r\n    */\n    let db = this;\n    let name;\n    let id;\n    let data = Object(_dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_1__[\"formatResponse\"])(responseText);\n    data.forEach(row => {\n      try {\n        name = row[0].toString().toUpperCase();\n        id = parseInt(row[1]);\n\n        if (isNaN(id)) {\n          // the first row will fail, because of the header, so don't throw an error\n          console.log(\"Oops! Node ID of \" + row[1]);\n        } else {\n          db.stuffToNodeId.set(name, id);\n        }\n      } catch (err) {\n        console.log(\"Invalid row: \" + row);\n        console.log(err.message);\n      }\n    });\n  }\n\n  parseConnData(responseText) {\n    /*\r\n    @param responseText : the result of an HTTP request to the node data spreadsheet\r\n    */\n    let data = Object(_dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_1__[\"formatResponse\"])(responseText);\n    let row;\n\n    for (let i = 1; i < data.length; i++) {\n      row = data[i];\n\n      try {\n        this.getNode(parseInt(row[0])).addAdjId(parseInt(row[1]));\n      } catch (e) {\n        console.log(\"Node not found: \" + parseInt(row[1]));\n        console.log(e.stack);\n      }\n    }\n\n    let db = this;\n    this.getAll().forEach(node => node.loadAdj(db));\n    this.logOneWayNodes();\n  }\n\n  parseImageResponse(csvFile) {\n    /*\r\n          @param csvFile : a CsvFile object containing the result of a HTTP request to our image spreadsheet\r\n          sets the connection images of nodes.\r\n    \r\n    Might redo this once we start working on images\r\n          */\n    let data = csvFile.getNonHeaders();\n    let fromCol = csvFile.indexOfCol([\"From\", \"node1\", \"n1\"]);\n    let toCol = csvFile.indexOfCol([\"to\", \"node2\", \"n2\"]);\n    let imgCol = csvFile.indexOfCol([\"image\", \"img\", \"photo\", \"url\"]); //Skip header\n\n    for (let i = 1; i < data.length; i++) {\n      //make sure all 3 rows exist\n      if (data[i][fromCol] !== \"\" && data[i][toCol] !== \"\" && data[i][imgCol] !== \"\") {\n        try {\n          this.getNode(parseInt(data[i][fromCol])).setConnectionImage(data[i][toCol], data[i][imgCol]);\n        } catch (e) {\n          console.log(\"An error occured while parsing image data:\");\n          console.log(e.stack);\n        }\n      }\n    }\n  }\n\n  parseClassResponse(csvFile) {\n    /*\r\n    @param responseText : the response from an XMLHTTP request \r\n    to a sheet containing class numbers and rooms\r\n    \r\n    We currenly can't use parseNameToId on this, as the class to building-room table does not use node IDs.\r\n    Once I implement that feature to the node manager, we can eliminate this.\r\n    */\n    let missingRooms = [];\n    let data = csvFile.getNonHeaders();\n    let classCol = csvFile.indexOfCol([\"CLASS NUMBER\", \"CLASS\"]);\n    let buildingCol = csvFile.indexOfCol([\"BUILDING\"]);\n    let roomCol = csvFile.indexOfCol([\"ROOM\"]);\n    let row;\n    let nodeId;\n\n    for (let i = 1; i < data.length; i++) {\n      row = data[i];\n      nodeId = this.getIdByString((row[buildingCol] + \" \" + row[roomCol]).toUpperCase());\n\n      if (nodeId == undefined) {\n        if (!missingRooms.includes(row[buildingCol] + \" \" + row[roomCol])) {\n          missingRooms.push(row[buildingCol] + \" \" + row[roomCol]);\n        }\n      } else {\n        if (!isNaN(parseInt(nodeId))) {\n          this.stuffToNodeId.set(row[classCol].toString().toUpperCase(), parseInt(nodeId));\n        }\n      }\n    }\n\n    if (missingRooms.length !== 0) {\n      console.log(\"Could not find a node connected to rooms...\");\n      missingRooms.forEach(room => console.log(\"-\" + room));\n      console.log(\"Check the current room to node file in the google drive to see if these rooms are missing nodes.\");\n    }\n  }\n\n  getNode(id) {\n    /*\r\n    @param id : a number, the ID of the node to return\r\n    @return a Node from the database with an ID matching the once passed in\r\n    TODO: decide what to do about invalid IDs\r\n    */\n    let ret = null;\n\n    try {\n      ret = this.nodes.get(parseInt(id));\n\n      if (!(ret instanceof _nodes_arcNode_js__WEBPACK_IMPORTED_MODULE_0__[\"Node\"])) {\n        throw Error(\"Node with id of \" + id + \" does not exist\");\n      }\n    } catch (e) {\n      console.log(e.stack);\n    }\n\n    return ret;\n  }\n\n  getIdByString(string) {\n    /*\r\n    @param string : a string, what to search for in buildings, rooms, and class numbers\r\n    \r\n    returns an integer, the id of the node with the given string associated with it, or undefined if it doesn't exist\r\n    \r\n    may move this to getNode, just making it check if parameter is integer or string. Could cause problems with class numbers\r\n    */\n    let ret = this.stuffToNodeId.get(string.toString().toUpperCase());\n\n    if (ret === undefined) {\n      console.log(\"Couldn't find node identified by \" + string);\n    }\n\n    return ret;\n  }\n\n  getAllNames() {\n    /*\r\n    Returns an array of strings,\r\n    the names of all named nodes\r\n    (buildings, rooms, etc)\r\n    */\n    return Array.from(this.stuffToNodeId.keys());\n  }\n\n  getAll() {\n    /*\r\n    Gets all the nodes stored here\r\n    */\n    return Array.from(this.nodes.values());\n  }\n\n  prettyPrintStuffToId() {\n    let longestName = 0;\n    this.getAllNames().forEach(name => {\n      if (name.length > longestName) {\n        longestName = name.length;\n      }\n    });\n    let spaceCount = 0;\n    let padding = \" \";\n    let i;\n    this.stuffToNodeId.forEach((id, name) => {\n      spaceCount = longestName - name.length;\n      padding = \" \";\n\n      for (i = 0; i < spaceCount; i++) {\n        padding += \" \";\n      }\n\n      console.log(name + padding + id);\n    });\n  }\n\n  logOneWayNodes() {\n    /*\r\n    Detects nodes with a one-way relationship with other nodes\r\n    ex. node 1 connects to node 2, but node 2 doesn't connect to node 1\r\n    fixes the errors\r\n    */\n    let allNodes = this.getAll();\n\n    for (let i = 0; i < allNodes.length; i++) {\n      let current = allNodes[i];\n\n      for (let j = 0; j < current.adj.length && current.id >= 0; j++) {\n        if (!current.adj[j].adjIds.includes(current.id)) {\n          //console.log(\"Node with ID \" + current.adj[j].id + \" needs to connect with node \" + current.id);\n          current.adj[j].adjIds.push(current.id);\n          current.adj[j].loadAdj(this);\n        }\n      }\n    }\n  }\n\n  countConnections() {\n    // counts how many different connections exist\n    let nodeConn = 0;\n    let allNodes = this.getAll();\n\n    for (let i = 0; i < allNodes.length; i++) {\n      nodeConn += allNodes[i].adj.length;\n    }\n\n    console.log(\"Total connections between nodes: \" + nodeConn);\n  }\n\n  generateDivs(main) {\n    //used to detect connection errors\n    this.getAll().forEach(node => node.generateDiv(main));\n  }\n\n  drawAll(canvas) {\n    //canvas is an instance of the program's Canvas object, not HTML canvas\n    this.getAll().forEach(node => {\n      node.draw(canvas);\n      node.drawLinks(canvas);\n    });\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/dataFormatting/nodeDB.js?");

/***/ }),

/***/ "./src/getRequests/importData.js":
/*!***************************************!*\
  !*** ./src/getRequests/importData.js ***!
  \***************************************/
/*! exports provided: newline, logger, get, sequentialGets, importMasterSheet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"newline\", function() { return newline; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logger\", function() { return logger; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sequentialGets\", function() { return sequentialGets; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"importMasterSheet\", function() { return importMasterSheet; });\n/* harmony import */ var _dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dataFormatting/csv.js */ \"./src/dataFormatting/csv.js\");\n/*\r\nProvides functions which are used to perform XMLHTTPRequests.\r\nThese are invoked in the html files.\r\n*/\n\nconst newline = /\\r?\\n|\\r/; //used for debugging\n\nconst logger = {\n  contents: [],\n\n  add(msg) {\n    \"use strict\";\n\n    this.contents.push(msg);\n  },\n\n  displayAll() {\n    \"use strict\";\n\n    for (let i = 0; i < this.contents.length; i++) {\n      console.log(this.contents[i]);\n    }\n  }\n\n}; // basic http request functions\n\nfunction get(url, callback) {\n  /*\r\n  fetch(url)\r\n  \t.then(\r\n  \t(response) => {\r\n  \t\tconsole.log(response);\r\n  \t\tcallback(response.text());\r\n  \t}\r\n  );*/\n  // callback is a function with a single parameter,\n  // passes in the url's response text as that parameter\n  let req = new XMLHttpRequest();\n\n  req.onreadystatechange = function () {\n    if (req.readyState === 4 && req.status === 200) {\n      logger.add(\"Response from \" + url + \":\");\n      logger.add(req.responseText);\n      callback(req.responseText);\n    }\n  };\n\n  req.onerror = function (e) {\n    console.log(e);\n    callback(\"\");\n  };\n\n  req.open(\"GET\", url, true); // true means asynchronous\n\n  req.setRequestHeader(\"Cache-Control\", \"max-age=0\"); // prevent outdated data\n\n  req.send(null);\n}\nfunction sequentialGets(urls, callbacks) {\n  /*\r\n  @param urls : an array of strings, the urls to get\r\n  @param callbacks : either...\r\n  (a): an array of functions, each taking a string as a paramter\r\n  (b): a single element array or function, taking an array of strings as a parameter\r\n    performs a get request on each url, then...\r\n  (a): if multiple callbacks are provided, passes in responses[i] to callback[i]\r\n  (b): if only one callback is passed (one element array, or just a function), passes in all responses as an Map to that function,\r\n  where the key is the URL, and the value is the response text\r\n  */\n  \"use strict\";\n\n  let responses = new Map();\n  let received = 0;\n  let singleFunction = !Array.isArray(callbacks) || callbacks.length === 1;\n\n  if (!Array.isArray(callbacks)) {\n    callbacks = [callbacks]; //make sure it's an array. Can't use singleFunction b/c single element array would cause problems\n  }\n\n  function finish() {\n    if (singleFunction) {\n      callbacks[0](responses);\n    } else {\n      let respArray = Array.from(responses.values()); // Maps retain insertion order, so this works\n\n      for (let i = 0; i < respArray.length && i < callbacks.length; i++) {\n        callbacks[i](respArray[i]);\n      }\n    }\n  }\n\n  function f(url) {\n    return function (responseText) {\n      responses.set(url, responseText);\n      received++;\n\n      if (received === urls.length) {\n        finish();\n      }\n    };\n  }\n\n  for (let i = 0; i < urls.length; i++) {\n    responses.set(urls[i], \"No response from URL \" + urls[i]);\n    get(urls[i], f(urls[i]));\n  }\n} // improve this\n\nfunction importMasterSheet(url, callback, options = {}) {\n  /*\r\n  @param url : a string, the \r\n  url of the master url file\r\n  on our google drive\r\n  @param callback : a function\r\n  This performs a get request on the master url spreadsheet,\r\n  then performs a get request on each url on the spreadsheet,\r\n  then passes each URL into the callback function\r\n  passes a Map, \r\n  with the keys being the identifier in the first column of the spreadsheet,\r\n  and the value is the response text from performing a get request on the url after that identifier;\r\n  into the callback\r\n   */\n  get(url, responseText => {\n    let data = Object(_dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_0__[\"formatResponse\"])(responseText);\n    let ignore = options.hasOwnProperty(\"ignore\") ? options[\"ignore\"] : [];\n    let urlToKey = new Map();\n    /*\r\n    since sequentialGets will return url-to-response,\r\n    we need to provide an easier way to identify what each response is giving.\r\n    since we are looking at key-to-url-to-response text,\r\n    and sequentialGets gives us url-to-response,\r\n    we can use this to get key-to-response text\r\n    */\n\n    for (let i = 1; i < data.length; i++) {\n      if (data[i][1] !== \"\" && ignore.indexOf(data[i][0]) === -1) {\n        /*\r\n        The data is a table, with the first column being a key,\r\n        such as \"node coordinates\", \"buildings\", etc,\r\n        \r\n        and the second being the url linking to that resource\r\n        */\n        urlToKey.set(data[i][1], data[i][0]);\n      }\n    }\n\n    function reformat(responses) {\n      /*\r\n      Convets the url-to-response result of seqGet\r\n      to an easier to use key-to-response\r\n      */\n      let ret = new Map();\n      responses.forEach((responseText, url) => {\n        ret.set(urlToKey.get(url), responseText);\n      });\n      callback(ret);\n    }\n\n    sequentialGets(Array.from(urlToKey.keys()), reformat);\n  });\n}\n\n//# sourceURL=webpack:///./src/getRequests/importData.js?");

/***/ }),

/***/ "./src/getRequests/urls.js":
/*!*********************************!*\
  !*** ./src/getRequests/urls.js ***!
  \*********************************/
/*! exports provided: mapURL, classesURL, masterSheetURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mapURL\", function() { return mapURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"classesURL\", function() { return classesURL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"masterSheetURL\", function() { return masterSheetURL; });\n/*\r\nThis file is used to specify the URLs used by this program to reteive data from external files.\r\n\r\n!!!!!\r\nIMPORTANT!!! : do NOT change ANYTHING to the left of the equal signs on each line! Doing so WILL break the program!\r\n!!!!!\r\n\r\nBefore changing this file, it might be a good idea to save a copy in case something goes wrong...\r\n*/\nconst mapURL = \"https://drive.google.com/uc?id=1Lt58PPBmimpY8hIlCJgg4qvF8CLt_mis\"; // this links to an image that is used as the campus map\n\n/*\r\nHOW TO CHANGE THE mapURL FILE:\r\n    Can't do yet, unless the map shows the same section of campus as the current one.\r\n\t1. Put a .png file into google drive.\r\n\t2. copy that image's URL using \"get sharable link\"\r\n\t3. paste the URL after var mapURL = ... in place of the existing URL\r\n\t4. make sure there are quote marks around the URL (can be double or single quotes)\r\n\t5. replace the \"open\" in the URL with \"uc\"\r\n\t6. ???\r\n*/\n\nconst classesURL = \"https://docs.google.com/spreadsheets/d/e/2PACX-1vREUvLP1uMDKADze2uCHx6jN4voxvO41g-gZ5pEDK_vJ0M9LA7UmfRgqJeX_NRDZsMMC_lOs2A0OKtm/pub?gid=57491238&single=true&output=csv\"; //the huge class data extract\n\nconst masterSheetURL = \"https://docs.google.com/spreadsheets/d/e/2PACX-1vSuRqzSZ2LyamtAz7Gs88JkOiBmyIx8ND6kqRhxbunGVPBw4Wqrc1yYgfjFeC6m_Dx0sbXTE4Q5k3uQ/pub?gid=0&single=true&output=csv\"; //the master spreadsheet containing links to all the data used by the program\n\n//# sourceURL=webpack:///./src/getRequests/urls.js?");

/***/ }),

/***/ "./src/htmlInterface/input.js":
/*!************************************!*\
  !*** ./src/htmlInterface/input.js ***!
  \************************************/
/*! exports provided: TextBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TextBox\", function() { return TextBox; });\n/*\r\nused to take input from the user\r\n\r\nfirst, accesses or creates two HTML elements,\r\none used for user input,\r\nthe second displays the closest match to what the user entered (see below)\r\n\r\nafter creating a TextBox, you will need to populate its option by calling...\r\ntextBox.addOptions(anArray);\r\n\r\nwhenever the user types in the text box, \r\nthe result element will search through options for the closest match to what the user entered,\r\nthen sets its text to that match.\r\n*/\nclass TextBox {\n  constructor(textBoxId, resultElementId) {\n    /*\r\n    @param textBoxId : a string, the id of an <input> HTML element with type=\"text\"\r\n    @param resultElementId : a string, the id of any HTML element whose inner HTML \r\n    will enter the option closest to the user's input\r\n      if either of the aforementioned elements don't exist, will create them instead\r\n    */\n    \"use strict\";\n\n    this.box = document.getElementById(textBoxId);\n    this.resultElement = document.getElementById(resultElementId);\n\n    if (this.box === null) {\n      this.box = document.createElement(\"input\");\n      this.box.setAttribute(\"type\", \"text\");\n      this.box.setAttribute(\"id\", textBoxId);\n      document.body.appendChild(this.box);\n    }\n\n    if (this.resultElement === null) {\n      this.resultElement = document.createElement(\"div\");\n      this.resultElement.setAttribute(\"id\", resultElementId);\n      document.body.appendChild(this.resultElement);\n    }\n\n    this.options = [\"your result will appear here!\"];\n    this.resultElement.innerHTML = \"your result will appear here!\";\n    this.box.oninput = this.updateResult.bind(this);\n  }\n\n  addOptions(options) {\n    /*\r\n    @param options : an array of strings\r\n    */\n    \"use strict\";\n\n    let b = this;\n    options.forEach(option => {\n      if (option) {\n        b.options.push(option.toString().toUpperCase());\n      }\n    });\n  }\n\n  updateResult() {\n    // makes the result search for the closest match in options to what the user's entered\n    \"use strict\";\n\n    this.resultElement.innerHTML = closestMatch(this.box.value, this.options);\n  }\n\n  isValid() {\n    //legal input was entered\n    \"use strict\"; //want to make sure the closest match is both in the options, and not the default option\n\n    return this.options.indexOf(this.resultElement.innerHTML.toUpperCase()) > 0;\n  }\n\n  setInput(str) {\n    //@param str : a string, what to put in the input box\n    //basically makes the program act as the user, typing str in the box\n    \"use strict\";\n\n    this.box.value = str;\n    this.box.oninput();\n  }\n\n  getResult() {\n    /*\r\n    @return : a string, the closest match to what the user inputted\r\n    */\n    \"use strict\";\n\n    return this.resultElement.innerHTML;\n  }\n\n}\n;\n\nfunction matchCount(find, inString) {\n  \"use strict\";\n  /*\r\n  returns the number of characters in find\r\n  that are in inString in order\r\n  */\n\n  find = find.toUpperCase();\n  inString = inString.toUpperCase();\n  let best = 0;\n  let spaces = 0;\n  let matchIdx; //the index in inString of the most recent letter match\n\n  let current;\n  let currentSpaces; // matchCount(\"string\", \"stri\") whould get a best of 4 on the first run,\n  // the next check would be for \"tring\" in \"stri\". (offset = 1)\n  // would not check with offset = 2, as it could not have more than 4 matches,\n  // so cannot be better than the current best of 4\n\n  for (let offset = 0; offset < find.length - best; offset++) {\n    current = 0; //number of matches in current substring\n\n    currentSpaces = 0;\n    matchIdx = 0;\n\n    for (let ind = 0; ind < inString.length && offset + current < find.length; ind++) {\n      //find[offset + current] will check the second character of the find substring after finding one match\n      //guarantees that the letters are in order\n      if (find[offset + current] === inString[ind]) {\n        current++;\n\n        if (current > 1) {\n          currentSpaces += ind - matchIdx - 1;\n        } else {\n          currentSpaces += ind;\n        }\n\n        matchIdx = ind;\n      }\n    }\n\n    if (current > best) {\n      best = current;\n      spaces = currentSpaces;\n    }\n  }\n\n  return {\n    \"matches\": best,\n    \"spaces\": spaces\n  };\n}\n\nfunction closestMatchIndex(string, options) {\n  \"use strict\";\n\n  let s = string.trim().toUpperCase();\n  let check = [];\n  let best = 0;\n  let leastSpaces = string.length;\n  let idxOfBest = 0;\n  let count;\n\n  for (let i = 0; i < options.length; i++) {\n    check.push(options[i].trim().toUpperCase());\n    count = matchCount(s, check[i]);\n\n    if (count.matches > best) {\n      best = count.matches;\n      leastSpaces = count.spaces;\n      idxOfBest = i;\n    } else if (count.matches === best) {\n      if (count.spaces < leastSpaces) {\n        best = count.matches;\n        leastSpaces = count.spaces;\n        idxOfBest = i;\n      }\n    }\n  }\n\n  return idxOfBest;\n}\n\nfunction closestMatch(s, options) {\n  // returns the string in options which most closely resembles s\n  \"use strict\";\n\n  return options[closestMatchIndex(s, options)];\n}\n\n//# sourceURL=webpack:///./src/htmlInterface/input.js?");

/***/ }),

/***/ "./src/htmlInterface/qrCodes.js":
/*!**************************************!*\
  !*** ./src/htmlInterface/qrCodes.js ***!
  \**************************************/
/*! exports provided: getIDsFromURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIDsFromURL\", function() { return getIDsFromURL; });\nfunction getIDsFromURL() {\n  /*\r\n  extracts variables from url.\r\n  defined as ?start=...&end=...\r\n  */\n  \"use strict\";\n\n  const query = window.location.href;\n  const values = [14, 96]; // check if parameters were passed\n\n  if (query.indexOf(\"?\") > -1) {\n    let args = query.split(\"?\")[1];\n    let pairs = args.split(\"&\");\n\n    for (let i = 0; i < pairs.length; i++) {\n      let pair = pairs[i].split(\"=\");\n      console.log(\"Pair: \" + pair);\n\n      if (pair[0].toUpperCase().includes(\"START\")) {\n        values[0] = pair[1];\n      } else if (pair[0].toUpperCase().includes(\"END\")) {\n        values[1] = pair[1];\n      }\n\n      values[pair[0]] = parseFloat(pair[1]);\n    }\n  }\n\n  return values;\n}\n\n//# sourceURL=webpack:///./src/htmlInterface/qrCodes.js?");

/***/ }),

/***/ "./src/htmlInterface/scaledCanvas.js":
/*!*******************************************!*\
  !*** ./src/htmlInterface/scaledCanvas.js ***!
  \*******************************************/
/*! exports provided: Canvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Canvas\", function() { return Canvas; });\n/*\r\nThe x and y coordinates given by the coordinate spreadsheet are those nodes' position on the autocad file where the data is extracted from.\r\nThis means that we can't draw point directly onto the SVG canvas, as the scaling is way off (x coordinates upwards of 2300 do not draw on a 1000 pixel canvas), and the autocad y-axis points upward (oh cartesian coordinates, why don't you point the logical way?) so all y - coordinates are negative, as the autocad map assigns coordinates from the upper-left corner (go figure)\r\n\r\nThis file is used to convert x y coordinates on the map image\r\nto x y coordinates on the SVG canvas.\r\nAlso provides canvas functions\r\n*/\nclass Canvas {\n  constructor() {\n    this.draw = undefined; // the svg image this corresponds to\n\n    this.scalingElement = undefined; // the svg element this gets its size from\n\n    this.width = 0; // dimensions of the svg element\n\n    this.height = 0;\n    this.minX = 0; // coordinates of the upper-leftmost and lower-rightmost nodes\n\n    this.minY = 0;\n    this.maxX = 0;\n    this.maxY = 0;\n    this.color = undefined;\n  }\n\n  link(svgDrawer, scaler) {\n    \"use strict\"; //better way?\n    //maybe built-in creating the svg?\n\n    try {\n      this.draw = svgDrawer;\n      this.scalingElement = scaler;\n      this.width = scaler.width;\n      this.height = scaler.height;\n    } catch (e) {\n      console.log(e.stack);\n    }\n  }\n\n  setColor(color) {\n    \"use strict\";\n\n    this.color = color;\n  }\n\n  rect(x, y, w, h) {\n    \"use strict\";\n\n    return this.draw.rect(w, h).attr({\n      fill: this.color\n    }).move(this.x(x), this.y(y));\n  }\n\n  clear() {\n    \"use strict\";\n\n    let a = this.draw.children();\n\n    for (let i = a.length - 1; i >= 0; i--) {\n      if (a[i].type === \"rect\" || a[i].type === \"line\" || a[i].type === \"text\") {\n        a[i].remove();\n      }\n    }\n  }\n\n  resize() {\n    \"use strict\";\n\n    this.width = this.scalingElement.width.baseVal.value;\n    this.height = this.scalingElement.height.baseVal.value;\n  }\n\n  text(text, x, y) {\n    \"use strict\";\n\n    this.draw.text(text.toString()).move(this.x(x) - 10, this.y(y) - 20).attr({\n      fill: this.color\n    });\n  }\n\n  line(x1, y1, x2, y2) {\n    \"use strict\";\n\n    this.draw.line(this.x(x1), this.y(y1), this.x(x2), this.y(y2)).stroke({\n      color: this.color,\n      width: 3\n    });\n  }\n\n  setCorners(x1, y1, x2, y2) {\n    // parameters are the corners of the map image used\n    // it's fine if the y axis is reversed\n    \"use strict\";\n\n    this.minX = x1;\n    this.minY = y1;\n    this.maxX = x2;\n    this.maxY = y2;\n    this.calcSize();\n  }\n\n  calcSize() {\n    \"use strict\";\n\n    this.mapWidth = this.maxX - this.minX;\n    this.mapHeight = this.maxY - this.minY;\n  }\n\n  x(coord) {\n    // convert a coordinate on the map image\n    // to a point on the SVG canvas\n    \"use strict\";\n\n    let percRight = (coord - this.minX) / this.mapWidth;\n    return percRight * this.width;\n  }\n\n  y(coord) {\n    \"use strict\";\n\n    let percDown = (coord - this.minY) / this.mapHeight;\n    return percDown * this.height;\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/htmlInterface/scaledCanvas.js?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! exports provided: Main */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Main\", function() { return Main; });\n/* harmony import */ var _nodes_path_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nodes/path.js */ \"./src/nodes/path.js\");\n/*\r\nThe Main class is used to store data, preventing the need for global letiables.\r\nIt also takes a lot of code out of the main HTML file.\r\n*/\n\nclass Main {\n  constructor() {\n    \"use strict\";\n\n    this.canvas = undefined; //html elements\n\n    this.start = undefined;\n    this.end = undefined;\n    this.pathButton = undefined;\n    this.currentPath = undefined;\n    this.nodeDatabase = undefined;\n    this.classDatabase = undefined;\n  }\n\n  setCanvas(canvas) {\n    \"use strict\"; // canvas is my custom Canvas class, NOT HTML canvas\n\n    this.canvas = canvas;\n  }\n\n  getCanvas() {\n    \"use strict\";\n\n    return this.canvas;\n  }\n\n  setInput(start, end) {\n    /*\r\n    start and end are TextBoxes.\r\n    Populates said TextBoxes with the contents of this' fake database\r\n    */\n    \"use strict\";\n\n    this.start = start;\n    this.end = end;\n    start.addOptions(this.getNodeDB().getAllNames());\n    end.addOptions(this.getNodeDB().getAllNames());\n  }\n\n  setClassFinder(nameTextBox, instructorTextBox, timesTextBox, buttonId, resultsId, clearId) {\n    /*\r\n    loads the contents of this' Class database into the options of the three passed in text boxes,\r\n    then makes button change the contents of result based on the results of each of the three boxes when clicked\r\n    \r\n    @param nameTextBox : a TextBox, used to allow the user to enter the name of their class\r\n    @param instructorTextBox : also a TextBox, where the user enters the name of the instructor for their class\r\n    @param timesTextBox : once more, a TextBox, used to enter the meeting time(s) for the class\r\n    @param buttonId : the id of an HTML element that can handle onclick events\r\n    @param resultsId : the id of a select element which will display the class numbers the user is searching for once the button is clicked\r\n    @param clearId : the id of an HTML element that can handle onclick events which, when clicked, will clear out each of the user input boxes\r\n    if either the buttonId, resultsId, or clearId elements do not exist, creates them for you\r\n    */\n    \"use strict\";\n\n    let db = this.getClassDB();\n    let main = this;\n    let button = document.getElementById(buttonId);\n    let result = document.getElementById(resultsId);\n    let clear = document.getElementById(clearId);\n\n    if (button === null) {\n      button = document.createElement(\"button\");\n      button.setAttribute(\"id\", buttonId);\n      button.innerHTML = \"Find class number\";\n      document.body.appendChild(button);\n    }\n\n    if (result === null) {\n      result = document.createElement(\"select\");\n      result.setAttribute(\"id\", resultsId);\n      document.body.appendChild(result);\n    }\n\n    if (clear === null) {\n      clear = document.createElement(\"button\");\n      clear.setAttribute(\"id\", clearId);\n      clear.innerHTML = \"Clear input\";\n      document.body.appendChild(clear);\n    }\n\n    nameTextBox.addOptions(db.getAllClassNames());\n    instructorTextBox.addOptions(db.getAllInstructors());\n    timesTextBox.addOptions(db.getAllMeetingTimes());\n\n    button.onclick = function () {\n      //first, gather all the data fields, then get class numbers from them\n      function toInt(num) {\n        /*\r\n        can't just do .map(parseInt), \r\n        as map will implicitly pass in the index as the second parameter of parseInt,\r\n        which is the base of the string passed in,\r\n        causing errors.\r\n        If no second parameter is given, parseInt defaults to base 10\r\n        */\n        return parseInt(num);\n      }\n\n      let results = [main.getClassDB().getNumbersByName(nameTextBox.getResult()).map(toInt), main.getClassDB().getNumbersByInstructor(instructorTextBox.getResult()).map(toInt), main.getClassDB().getNumbersByTime(timesTextBox.getResult()).map(toInt)]; //this is an array of arrays\n\n      let validResults = []; //which results can be compared\n\n      let setTo = [\"class not found\"]; //what the dropbox will be set to\n      //then, check if the result set contains any data.\n      //this way, we won't be comparing valid data to an empty set\n\n      results.forEach(array => {\n        if (array.length > 0) {\n          validResults.push(array);\n        }\n      });\n\n      if (validResults.length === 0) {\n        setTo = [\"class not found\"];\n      } else if (validResults.length === 1) {\n        setTo = validResults[0];\n      } else {\n        //find a class present in each data set\n        //iterate through each element in the first set of valid results\n        validResults[0].forEach(item => {\n          setTo = [];\n          let match = true; //check if each other valid result set contains said value\n\n          for (let i = 1; i < validResults.length && match; i++) {\n            match = validResults[i].indexOf(item) !== -1;\n          }\n\n          if (match) {\n            setTo.push(item);\n          }\n        });\n      } //erase the current contents of dropdown\n\n\n      while (result.length > 0) {\n        result.remove(result.length - 1);\n      } //then repopulate it\n\n\n      let newElem;\n      setTo.forEach(opt => {\n        newElem = document.createElement(\"option\");\n        newElem.text = opt;\n        result.add(newElem);\n      });\n      result.onchange();\n    };\n\n    clear.onclick = function () {\n      nameTextBox.setInput(\"\");\n      instructorTextBox.setInput(\"\");\n      timesTextBox.setInput(\"\");\n    };\n\n    result.onchange = function () {\n      nameTextBox.setInput(db.select(db.NAME, db.NUMBER, result.value)[0]);\n      instructorTextBox.setInput(db.select(db.INSTRUCTOR, db.NUMBER, result.value)[0]);\n      timesTextBox.setInput(db.select(db.MEETING_TIME, db.NUMBER, result.value)[0]);\n    };\n  }\n\n  setPathButton(id) {\n    /*\r\n    id is the id of any HTML element\r\n    if it doesn't exist, will create it for you\r\n    */\n    \"use strict\";\n\n    this.pathButton = document.getElementById(id);\n\n    if (this.pathButton === null) {\n      this.pathButton = document.createElement(\"button\");\n      this.pathButton.setAttribute(\"id\", id);\n      this.pathButton.innerHTML = \"Draw Path\";\n      document.body.appendChild(this.pathButton);\n    }\n\n    let main = this;\n\n    this.pathButton.onclick = function () {\n      if (main.start.isValid() && main.end.isValid()) {\n        //updatepath does the finding\n        main.updatePath(main.start.getResult(), main.end.getResult());\n      }\n    };\n  }\n\n  setPath(path) {\n    \"use strict\";\n\n    if (path.valid) {\n      this.currentPath = path;\n\n      try {\n        path.draw(this.canvas);\n      } catch (e) {\n        console.log(\"Main's canvas is not defined yet\");\n        console.log(e.stack);\n      }\n    }\n  }\n\n  getPath() {\n    \"use strict\";\n\n    return this.currentPath;\n  }\n\n  updatePath(data1, data2) {\n    \"use strict\";\n\n    try {\n      let start = this.getNodeDB().getIdByString(data1);\n      let end = this.getNodeDB().getIdByString(data2); //single equal will catch both null and undefined\n\n      if (start != null && end != null) {\n        //otherwise some class numbers cause problems\n        let newPath = new _nodes_path_js__WEBPACK_IMPORTED_MODULE_0__[\"Path\"](start, end, this);\n\n        if (newPath.valid) {\n          this.setPath(newPath);\n        } else {\n          throw new Error(\"Invalid path: \" + newPath.idPath);\n        }\n      } else {\n        throw new Error(\"Invalid start and end points: \" + data1 + \" \" + data2);\n      }\n    } catch (e) {\n      console.log(e.stack);\n    }\n  }\n\n  testAllPaths() {\n    //developer tool. Detects any paths between any two nodes that cannot exist\n    \"use strict\";\n\n    let source = this;\n    let nodeDB = source.getNodeDB();\n    let points = [];\n    points = points.concat(nodeDB.getAllNames());\n\n    function checkPath(startStr, endStr) {\n      try {\n        let id1 = nodeDB.getIdByString(startStr);\n        let id2 = nodeDB.getIdByString(endStr); //getIdByString will log any errors\n\n        if (id1 != null && id2 != null) {\n          let path = new _nodes_path_js__WEBPACK_IMPORTED_MODULE_0__[\"Path\"](id1, id2, source);\n\n          if (!path.valid) {\n            throw new Error(\"Invalid Path: \" + path.idPath);\n          }\n        }\n      } catch (e) {\n        console.log(e.stack);\n      }\n    }\n\n    alert(\"Please wait while I process \" + points.length * points.length + \" paths...\");\n\n    for (let i = 0; i < points.length; i++) {\n      for (let j = 0; j < points.length; j++) {\n        checkPath(points[i], points[j]);\n      }\n    }\n\n    alert(\"Done.\");\n  }\n\n  setNodeDB(database) {\n    \"use strict\";\n\n    this.nodeDatabase = database;\n  }\n\n  getNodeDB() {\n    \"use strict\";\n\n    return this.nodeDatabase;\n  }\n\n  setClassDB(database) {\n    \"use strict\";\n\n    this.classDatabase = database;\n  }\n\n  getClassDB() {\n    \"use strict\";\n\n    return this.classDatabase;\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ }),

/***/ "./src/nodes/arcNode.js":
/*!******************************!*\
  !*** ./src/nodes/arcNode.js ***!
  \******************************/
/*! exports provided: Node */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Node\", function() { return Node; });\nclass Node {\n  constructor(id, x, y) {\n    /*\r\n    id is a unique identifier\r\n    like a primary key\r\n        x and y are coordinates on the map image,\r\n    as extracted from the node spreadsheet.\r\n    */\n    try {\n      this.id = parseInt(id);\n\n      if (isNaN(this.id)) {\n        throw new TypeError(\"Node id must be an integer\");\n      }\n    } catch (idError) {\n      console.log(idError.stack);\n    }\n\n    try {\n      this.x = parseFloat(x);\n      this.y = parseFloat(y);\n\n      if (isNaN(this.x) || isNaN(this.y)) {\n        throw new TypeError(\"X and Y must be numbers\");\n      }\n    } catch (latLngError) {\n      console.log(latLngError);\n    }\n\n    this.adjIds = [];\n    /*\r\n          adjIds is an array of ints,\r\n          each int represents the id\r\n          of an adjacent node.\r\n          i.e. you can travel from this point to that one\r\n          */\n\n    this.connectionImages = {};\n    /*\r\n    key is the id of a node this connects to,\r\n    value is the URL of an image of the path between this node and that one\r\n    */\n  }\n\n  loadAdj(nodeDB) {\n    /*\r\n    Creates an array of Nodes,\r\n    the array contains all the\r\n    Nodes adjacent to this one.\r\n    \n    Has to be invoked after \r\n    initializing all Nodes,\r\n    otherwise you will reference\r\n    nonexistant variables.\r\n    \n    automatically invoked by importNodeData\r\n    */\n    \"use strict\";\n\n    this.adj = [];\n    let check;\n\n    for (let i = 0; i < this.adjIds.length; i++) {\n      check = nodeDB.getNode(this.adjIds[i]);\n\n      if (check) {\n        this.adj.push(check);\n      }\n    }\n  }\n\n  distanceFrom(n2) {\n    \"use strict\";\n\n    return Math.sqrt(Math.pow(this.x - n2.x, 2) + Math.pow(this.y - n2.y, 2));\n  }\n\n  addAdjId(id) {\n    \"use strict\";\n\n    this.adjIds.push(id);\n  }\n\n  setConnectionImage(id, url) {\n    // invoked by importImages in import data file\n    // sets the image going from this node to node with id equal to the id passed\n    \"use strict\";\n\n    this.connectionImages[id] = url;\n  }\n\n  getHasImage(id) {\n    // returns whether or not an image has been given showing the area \n    //between this node and node with id equal to the id passed\n    \"use strict\";\n\n    return this.connectionImages.hasOwnProperty(id);\n  }\n\n  getImageTo(id) {\n    // returns the image of going from this node to node with id equal to the id passed\n    \"use strict\";\n\n    return this.connectionImages[id];\n  }\n\n  draw(canvas) {\n    \"use strict\";\n\n    canvas.setColor(\"red\");\n    canvas.rect(this.x, this.y, 5, 5);\n  }\n\n  drawId(canvas) {\n    \"use strict\";\n\n    canvas.setColor(\"red\");\n    canvas.text(this.id, this.x, this.y);\n  }\n\n  drawLinks(canvas) {\n    // draws lines connecting this node to its adjacent nodes\n    \"use strict\";\n\n    canvas.setColor(\"red\");\n    this.drawId(canvas);\n\n    for (let j = 0; j < this.adj.length; j++) {\n      this.adj[j].draw(canvas);\n      canvas.line(this.x, this.y, this.adj[j].x, this.adj[j].y);\n    }\n  }\n\n  generateDiv(main) {\n    // used for testing\n    \"use strict\";\n\n    let node = this;\n    let canvas = main.getCanvas(); //draws this node's links\n\n    let f = function () {\n      node.draw(canvas);\n      node.drawLinks(canvas);\n    }; //redraws the current path\n\n\n    let f2 = function () {\n      canvas.clear();\n      let path = main.getPath();\n\n      if (path !== undefined) {\n        path.draw(canvas);\n      }\n\n      main.getNodeDB().generateDivs(main);\n    }; //logs the node's data\n\n\n    let f3 = function () {\n      console.log(node);\n    };\n\n    node.drawId(canvas);\n    canvas.rect(this.x, this.y, 10, 10).mouseover(f).mouseout(f2).click(f3); //                                            ^ display links when hovered over,\n    //                                                        ^ redraw the path when mouse exits\n    //                                                                  ^ display data when clicked\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/nodes/arcNode.js?");

/***/ }),

/***/ "./src/nodes/path.js":
/*!***************************!*\
  !*** ./src/nodes/path.js ***!
  \***************************/
/*! exports provided: Path */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Path\", function() { return Path; });\n/*\r\nPath is used to store a collection of Nodes that connect together\r\nto form a path between two Nodes. \r\n\r\nHOW A PATH IS FOUND:\r\n1. Every Node has a list of Nodes that connect to it, called adjacent nodes.\r\n2. If node A is adjacent to node B, then a path exists between them.\r\n3. Similarly, if node B also connects to node C, then there exists a path A-B-C\r\n4. Now, repeat this process until there exists a path between the start and end points given.\r\nread this for a better explaination: https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\n*/\n//use this in conjunction with Node\nclass Path {\n  constructor(startId, endId, dataSource) {\n    /*\r\n    start and endId are node IDs\r\n    dataSource is a Main object\r\n    \r\n    idPath is an array of numbers, the ids of the nodes the path goes through\r\n    nodePath is the corresponding nodes\r\n    pathLength is the total length of the distance between all the nodes used in the path\r\n        it doesn't matter what scale it's in, as it is just used to compare in bestPath\r\n    images is an array of strings, the URLs of the path's images\r\n    imageInd is the index of the image currently displayed in main (in development)\r\n    */\n    this.startId = parseInt(startId);\n    this.endId = parseInt(endId);\n    this.dataSource = dataSource;\n    this.valid = true;\n    this.idPath = [];\n    this.nodePath = [];\n    this.pathLength = 0;\n    this.loadPath();\n    this.decodeIds();\n    this.images = this.getImages();\n    this.imgInd = -1; // increments before getting image\n  }\n\n  decodeIds() {\n    // generates nodePath\n    this.nodePath = [];\n\n    for (let i = 0; i < this.idPath.length; i++) {\n      this.nodePath[i] = this.dataSource.getNodeDB().getNode(this.idPath[i]);\n    }\n  }\n\n  loadPath() {\n    /*\r\n    this is the big one.\r\n    \t\tDijkstra's algorithm.\r\n    https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\r\n    Thanks Kevin\r\n    sets this.idPath to shortest path when complete\r\n    */\n    if (this.startId === this.endId) {\n      this.idPath = [this.startId];\n      this.pathLength = 0;\n      return;\n    }\n\n    let nodeDB = this.dataSource.getNodeDB();\n    let allNodes = nodeDB.getAll(); // start by declaring letiables\n\n    let unvisited = []; // unchecked nodes. Store as Node.\n\n    let dists = {}; // distances from start. Store as id : number\n\n    let prev = {}; // previous node in best path. Store as id : id\n    // initialize values\n\n    for (let i = 0; i < allNodes.length; i++) {\n      unvisited[i] = allNodes[i];\n      dists[allNodes[i].id] = Infinity;\n      prev[allNodes[i].id] = undefined;\n    }\n\n    dists[this.startId] = 0; // distance from start to start is 0\n\n    function smallestIndex() {\n      /*\r\n      Returns the index of the node with the shortest distance from start\r\n      that has yet to be visited\r\n      */\n      let index = 0;\n\n      for (let i = 0; i < unvisited.length; i++) {\n        if (dists[unvisited[i].id] < dists[unvisited[index].id]) {\n          index = i;\n        }\n      }\n\n      return index;\n    } // run while there are still nodes to visit\n\n\n    while (unvisited.length > 0) {\n      let index = smallestIndex();\n      let nearest = unvisited[index];\n      unvisited.splice(index, 1); // remove nearest from unvisited, as we are visiting it\n      // find which of its adjacent nodes are closest to start\n\n      for (let j = 0; j < nearest.adj.length; j++) {\n        if (unvisited.includes(nearest.adj[j])) {\n          let check = dists[nearest.id] + nearest.distanceFrom(nearest.adj[j]); // distance from start to i\n          //                                                V     is this right?\n\n          if (dists[nearest.adj[j].id] === Infinity || check < nearest.adj[j].distanceFrom(nodeDB.getNode(this.startId))) {\n            dists[nearest.adj[j].id] = check;\n            prev[nearest.adj[j].id] = nearest.id;\n          }\n        }\n      }\n    } // generate the path\n\n\n    let path = [];\n    let id = this.endId;\n\n    while (prev[id] !== undefined) {\n      path.push(id);\n      id = prev[id];\n    }\n\n    if (nodeDB.getNode(this.startId).adjIds.indexOf(path[path.length - 1]) !== -1) {\n      path.push(this.startId);\n    }\n\n    path = path.reverse();\n    this.idPath = path;\n    this.pathLength = dists[this.endId];\n\n    if (this.startId !== this.idPath[0] || this.endId !== this.idPath[this.idPath.length - 1]) {\n      this.invalidate();\n    }\n\n    if (this.startId < 0 || this.endId < 0) {\n      this.invalidate();\n    }\n  }\n\n  invalidate() {\n    if (this.valid) {\n      //prevent doubling up on this message\n      this.valid = false;\n\n      try {\n        console.log(\"Invalid path detected: \");\n        console.log(this);\n        throw new Error();\n      } catch (e) {\n        console.log(e.stack);\n      }\n    }\n  }\n\n  getURL() {\n    let origURL = window.location.href;\n    let split = origURL.split(\"?\");\n    return split[0] + \"?startID=\" + this.idPath[0] + \"&endID=\" + this.idPath[this.idPath.length - 1];\n  }\n\n  draw(canvas) {\n    canvas.clear();\n    canvas.setColor(\"red\");\n    let p = this.nodePath;\n    p[0].draw(canvas);\n\n    for (let i = 1; i < p.length; i++) {\n      canvas.line(p[i - 1].x, p[i - 1].y, p[i].x, p[i].y);\n      p[i].draw(canvas);\n    }\n  }\n\n  getImages() {\n    // returns an array of strings, each element is the url of a path image\n    let ret = [];\n    let ind = 0;\n\n    while (ind + 1 < this.idPath.length) {\n      ind++; // skips 0 so we can compare two nodes\n\n      let n1 = this.nodePath[ind - 1];\n      let n2 = this.nodePath[ind];\n\n      if (n1.getHasImage(n2.id)) {\n        let url = n1.getImageTo(n2.id);\n\n        if (ret.indexOf(url) === -1) {\n          ret.push(url);\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  nextImage() {\n    // grabs the next image from this.images\n    // make sure not to go out of range\n    if (this.imgInd + 1 < this.images.length) {\n      this.imgInd++;\n    } else {\n      this.imgInd = 0;\n    }\n\n    return this.images.length !== 0 ? this.images[this.imgInd] : \" \"; // if this path has no images, return a blank string\n  }\n\n}\n;\n\n//# sourceURL=webpack:///./src/nodes/path.js?");

/***/ }),

/***/ "./src/webpages/index.js":
/*!*******************************!*\
  !*** ./src/webpages/index.js ***!
  \*******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _htmlInterface_qrCodes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../htmlInterface/qrCodes.js */ \"./src/htmlInterface/qrCodes.js\");\n/* harmony import */ var _htmlInterface_scaledCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../htmlInterface/scaledCanvas.js */ \"./src/htmlInterface/scaledCanvas.js\");\n/* harmony import */ var _nodes_path_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../nodes/path.js */ \"./src/nodes/path.js\");\n/* harmony import */ var _main_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../main.js */ \"./src/main.js\");\n/* harmony import */ var _htmlInterface_input_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../htmlInterface/input.js */ \"./src/htmlInterface/input.js\");\n/* harmony import */ var _getRequests_importData_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../getRequests/importData.js */ \"./src/getRequests/importData.js\");\n/* harmony import */ var _dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dataFormatting/csv.js */ \"./src/dataFormatting/csv.js\");\n/* harmony import */ var _getRequests_urls_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../getRequests/urls.js */ \"./src/getRequests/urls.js\");\n/* harmony import */ var _dataFormatting_nodeDB_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dataFormatting/nodeDB.js */ \"./src/dataFormatting/nodeDB.js\");\n\n\n\n\n\n\n\n\n\nvar master = new _main_js__WEBPACK_IMPORTED_MODULE_3__[\"Main\"](); //http://svgjs.com/\n\nvar svgDrawer = SVG('wrapper').size(1000, 1000).panZoom();\nvar svgMap = svgDrawer.image(_getRequests_urls_js__WEBPACK_IMPORTED_MODULE_7__[\"mapURL\"]);\nsvgMap.loaded(function () {\n  console.time(\"Time to load\"); // need to wait to invoke since we need image width\n\n  var nodes = new _dataFormatting_nodeDB_js__WEBPACK_IMPORTED_MODULE_8__[\"NodeDB\"]();\n  var masterCanvas = new _htmlInterface_scaledCanvas_js__WEBPACK_IMPORTED_MODULE_1__[\"Canvas\"]();\n  var ids;\n  var start = new _htmlInterface_input_js__WEBPACK_IMPORTED_MODULE_4__[\"TextBox\"](\"start box\", \"start hint\");\n  var end = new _htmlInterface_input_js__WEBPACK_IMPORTED_MODULE_4__[\"TextBox\"](\"end box\", \"end hint\");\n  master.setNodeDB(nodes);\n  masterCanvas.link(svgDrawer, document.getElementById(\"wrapper\").getElementsByTagName(\"svg\")[0].getElementsByTagName(\"image\")[0]);\n  masterCanvas.resize();\n  master.setCanvas(masterCanvas);\n  Object(_getRequests_importData_js__WEBPACK_IMPORTED_MODULE_5__[\"get\"])(_getRequests_urls_js__WEBPACK_IMPORTED_MODULE_7__[\"masterSheetURL\"], console.log);\n  Object(_getRequests_importData_js__WEBPACK_IMPORTED_MODULE_5__[\"importMasterSheet\"])(_getRequests_urls_js__WEBPACK_IMPORTED_MODULE_7__[\"masterSheetURL\"], responses => {\n    nodes.parseNodeData(responses.get(\"Node coordinates\"));\n    nodes.parseConnData(responses.get(\"Node connections\"));\n    masterCanvas.setCorners(nodes.getNode(-1).x, nodes.getNode(-1).y, nodes.getNode(-2).x, nodes.getNode(-2).y);\n    nodes.parseNameToId(responses.get(\"buildings\"));\n    nodes.parseNameToId(responses.get(\"rooms\"));\n    nodes.parseImageResponse(new _dataFormatting_csv_js__WEBPACK_IMPORTED_MODULE_6__[\"CsvFile\"](responses.get(\"images\"))); //nodes.parseClassResponse(new CsvFile(responses.get(\"class to room\")));\n\n    master.setInput(start, end);\n    master.setPathButton(\"button\");\n    ids = Object(_htmlInterface_qrCodes_js__WEBPACK_IMPORTED_MODULE_0__[\"getIDsFromURL\"])();\n    master.setPath(new _nodes_path_js__WEBPACK_IMPORTED_MODULE_2__[\"Path\"](ids[0], ids[1], master));\n    master.getPath().draw(master.getCanvas());\n    console.timeEnd(\"Time to load\"); //nodes.prettyPrintStuffToId();\n  }, {\n    ignore: [\"map image\", \"classes\", \"class to room\"]\n  });\n});\n\nfunction nextImage() {\n  if (master.getPath() !== undefined) {\n    document.getElementById(\"image\").src = master.getPath().nextImage();\n  }\n}\n\nwindow.addEventListener(\"resize\", function () {\n  master.getCanvas().resize();\n\n  if (master.getPath() !== undefined) {\n    master.getPath().draw(master.getCanvas());\n  }\n});\n\n//# sourceURL=webpack:///./src/webpages/index.js?");

/***/ })

/******/ });